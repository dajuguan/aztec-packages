{"noir_version":"0.24.0+e80c5f73a4cdcba3f5cf44576c605ba1e611a2ab","name":"BoxReact","functions":[{"name":"setNumber","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::context::globals::private_global_variables::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"},{"name":"number","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":41}],"number":[{"start":41,"end":42}],"owner":[{"start":42,"end":43}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_key_validation_requests","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}}]}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323]},"bytecode":"H4sIAAAAAAAA/+1dB3hdR5Wep94td1lu15Yt25Isv6diPeEALwmBQAI4CRDaAnL0FLzYVpBlEtNL6L33FnrvvQW2siy7bKHsAgtkC8sCWbYA2WXxMuf5nrxfRyNFejrzcu83mu+b9+6dO3fm/8/MnOlzr8oYM2AtGfqrsbbW2gju6+Jrvq8X9w3ivlG83yzu14n7DeJ+k7jvEvfd8T2amIIpxP/D2cMjI8WxoWJuODeRHRo/lh/NjoweO5zP5XOj+dHJofzwcDE/kh8bPzY+lh3PjQwXc1Oj48NT2fOmH8LKrtAQtibAfMDac9b2xf/9gf0PxFbKZSBQeaBcDprz5Y/zMxqZx7MrMznFsLKId9Cc1xFkGhz42dQ6rpvA3zllrhiXxNLpwDkvDQqKYHwk5qCHcA8ZPaXqi/ch/TTK1joyRClcc75CI9ME7pFW3CPZXKnQ1BmnocqVC1cr+KuJ3TrBjXG3WNsRX19bnL1y4tTk9Ml7Hi+emERmNQ620lCMtcJ/K1zzs2bjufgYAZbDXmkWzSni5PqNhUNhY71PZshUT98PGT/6ftis6vs7BOMjMYc9hDtikq3vifeIfhpljSND+JBpdoUmjcqiEXCOxv+H4/+x+D8f/4/H/3eJ/49Yuz2uzzzVt3msb6VssXZjP8SnDZ5nRB1ceid2qwW32ro5wZTc6uIbrNPrY7cGcGuAuNmtUcilE7CwvyYzV9kW4uvsCk0T4IsUwy3JxMw1Mk0iuG4AbvX6eHK+eDaZcrppy6/BLF1+TfDf6El+PnhSmC2e5Ndkli6/FpBfsyf5+eBJ4bZ5kl+LWbr82kB+rZ7k54MnhdvhSX5tZuny6wD5tXuSnw+ensIt4V3jCW8nyFoT73p9vHnKR2vN0vPReuC2zlO6eOBZSpcNwE8rXApjI8hnrZBTOzzfALLb6EF2GYiXw+b7jY64FTvSJTlsugM5bHJg2VRlOSDGVbyreFfxJg/vhgTgpbg3q8edG2sVcZNZrL7d7FkWfnierw+6gMd6wacdnmP+7PLAMQPxcth8jxhX8a7iXcW7incV7yreVbyreFfxruJdxbuKdxXvKt7Q8VLcW/TjHm4VcZPJiPsIrrd4loUnnqXxkG7gsVnwaYfnmN7dHjhmIF4Om+8R4ypef3jb4XkN4PGQ93JLKU+IJ5MAPK3GvcZqi5AZubFMcQ3V1vga11Bti69xDdX2+BrXUO2Ir3EN1U5Tlgm7RfF1M7jtiq9bwG03XPN/T3yN68P2xNft4LY3vu4At974eg247YuvO8Ftf3y9FtwOxNfrwK0vvl4Pbv3x9SZwG4ivN4Pbwfi6C9w4bTAtOW26wY3TZiu4cdpsAzdOm+3gxmmzA9w4bXaCG661YTdOm13gxmmDacVp0wNunDZ7wI3TZi+4cdr0ghunzT5w47TZD26cNgfAjdOmD9x4nqQf3Fi3DYAbpyGnFcnuPpnyc34fyxTHg2XqoCO+AQcuvkY9wu9ERlePYFwR3HN8bYCjLyF4ahx4OK0LenhKax726/PMEzfOww1x2Iyf46sDP3VxAnCZYHcynKcOgHz6hT/kUTC6bb1eT/LZK+TD+HtBPrfrCyEfdkf57Af57BP+kEfBqPEYonD3eJJPj5AP498D8mE/64R82B3l0wvy2Sv8IY+C0eu7ULi7Pclnl5AP498N8mE/W4R82B3lswfk0yP8IY+CUeMxgpt2teWzU8gH04Hlw34iIR92R/nsBvnsEv6QR8Go8RilcHd4ks92IR/GvwPkw372CfmwO8onAvnsFP6QR8Go8ThM4W7zJJ+tQj6MfxvIh/0MCvmwO8pnB8hnu/CHPApGjceYp/5rHvuvLB/G3w3yYT+jQj5bHPLZBvLZKvw1gb+M0W2PcfuUD6PoF7jqwM8R4IHtYmyvs19s6zMP7CewnLCPMRhfY/+E9yRj34Y3mWG/iNuM2Pbmtjm29blPhX0v7lNh34v7VIPgxn2qQ+DGfSrG1Gy8jZsMoSzZZMR9BNc4lsLvYV+3W8iCcG/Vx13KZ90CI99vBYzstg7w+Bp/qhd4ZB7wGXejiLuxinE3i7ibqxh3q4i7tYpxt4u426sY9wYR9wYR90Jjnb7wGIHHLIKnIWF4GhOGZ33C8GxIGJ41CcPTkjA8rQnDU5cwPPUJw7M2YXiq0VZaDp6OhOFpShie5oThqU0Yni0Jw7M5YXi6EoanGmsFloNnU8LwdCYMT1vC8LQnDE8mAXgWWtvBz3EemsdPcB4ax2jZjcfPcG0Hj8ni2g4ee8O1HZEpy4TdeNwO13bwHAGu7cAxP/7HuRZ24/FCXNvBc1a4toPHGnFtx/74Gtd28Hwprtng+eQN4MayRNmzLHF8kWWJ6y5Yljg2ybLEdRcsSxzXZFlG4MayxDFRliWuu2BZomxZlrjugmWJY7EsS1x3IeedcS0Grrvgti+uu+D2J8uWuPJZTJg2mGc5HsyzfY74Djhw8TWWUw9z+KVyinFFcI9zzRmB8c7G054wPG0Jw9OZMDybEoZnY8LwdCUMz+aE4dmSMDy1CcPTnDA8TQnD05EwPOsShmdtwvDUJwxPXcLwtCYMT0vC8KxJGJ4NCcOzPmF4GhOGpyFheGqqiIf7oxy2XNNNcXtYZ1xap75XnVNujDjxeIFcZ8zx1YGfPbGwWYewOxnuv+M64/3CH/JYydl6U8JkRBznIG6Or8aBpyAwFYxefqFweXwmMrppxmNBnGZyPXcd+BkUacbuZPqEjNrM/HXUTcbLGu5SeVoHWCK4x7Eu7m9xvqL2z0hNGZuP8oa6pz4OV+LA/RsX1ZT95mvKspTr63BsFue5tnuSL8fFYfM9x4drTXFcU+7FRNyuNZeufWzsn79ggvthCqYsTy6TKM9LQJ5frS3LyUNajyK2GuNOa3LnMsJ+z8WYeuC+UkwufcZloDEOe7EyfjmUcU/6bChj5u4rKThkUgPXPUJOuz3JaZeQE8fv2gdylZAT+42Mrn7m+Fg/9wg5IaarhX5mdzJ9QpZtwIv9IY+C0dUfiKXg4FFjyvMX7JfTeyfcFyrE5Epv3Ht8DuLfCbJlP48S6c1+I6Ob3jiPFoEsIgemSZHe7E6mT8gS95Kwvya41vzQD6Y3t6Fk3DXgxn4zsV0or2D7S+6rOqfIx5VXojgszis9gk8d+JkWecXDvqNF+xCYvvrtxvN7BzCvkcmI+wiucW+gh/bJMM4NLwUP7qWK9PHkPPEs9d24LaR9nvhWR3oxh3Yzv23XZPzt79gu0k3u8VrF6xcv4dkhsOK6jx0JwYhljPGwW0EPT+n7Hzx3iGtfXuS37zjs6uswDlff8eu1ZWwvg74jP8d1JHuFm6e6opSWuMc+MvP7H21m/liRz3qzV+DpdcjizozbQ58r6yl9h119FFf/kv28ZZE+ijxroQ3kgu3JHn355Dy1BYZRl8k+XATyYT/vEvLZ7pAPlptdwh/yKBi9Nh+2PSJl+cj94YzftT/8g0I+Wx3yiUA+rv3h+n31bA7XGLJZrA2Kcww+6lBc37YUPK7989p4ti4DD7aDfKydxXHIpeDBvZ39nvB0LwNPP+AZ8ISnfxl4BgDPQU94BpaBhzFQO1HWseTGZWMXuHH+xHY55xE8L47TaTe4yXO92gEvj3O0gRuOc7v2zvsogxmz8N55PDOCuXQ78BT08OQRjxwvd/WDMka3vveQT0uc+JyHBiFjPAeD/XxHjBUNesDkq0xSGIeAk+u8D37+fZiH+UF8jXUUnh1yq+M5m8XKPMuO+Ob0+Zbm8obisDhtc464hwGrUtw5jJvHSTkedq+D65+zIgJ/ZFjOjJvKe9bhD6/3iXfa4XnWwTtS5o1fjo/gnuOjPHML5K9bHf1yTUzIG+WDe4DkuTLEA+vTAvjH8dFD+nhLOonLJOdbxoLll/38SugkH3rSE9dS2gwCp14HT37+G8gzvwWdw+mC8/ZttfOfs1lKO+TO0EkYdxJ0UitP6JvF9ctSdFK3eCeJOsnAeFwbrD3w0V5H3iiffpAPP+d2cMbMnccpgH/USR76y852EmPBuW32syGWn+92ko+xAQoD9c+Agyc/3wJ5ZivoHNkmp+d9judsltpOyurzzWL54LTNOuJG3aEU95yyyTqJ42H3Org+ADppqHx5u5wZN+mkgw5/eN0v3mmH5wcdvCNl3lj+I7jn+CjP7ID81edYD6WJCXmjfLAfzs+5H048sJ9fMPPnoprM3HURBR28JZ3E5ZDz7YDAh2V1SOgkH203T1xLaYP6p9fBk5+PQZ4ZB53D6cLpSs8vdTxns5hOYtl5am9msXxw2h50xI26QynuOWWTdRLHw+51cH0v0EnYzpD9a9JJgw5/eL1DvNNu3H1WD23THPY7OOyDAiPlmQsgf10KOsnHuC/yRvkMgHz4OY8D4hyOibGwf9RJHsaFnee/MxaOD8vqUaGTfLTdfI2BUxiof7odPPn5AyHPXA06h9OF05WeTzmes1lMJ+EcjYf2ZtbVLx90xI26QynuOWWTdRLHg+N3fF0EnYTtDJYz4yaddMjhD68HxDvYNznk4B0p88byH8E9x0d55qGQv6aq0E465JAPzkPwc56HkGP5BfBfjXYSl0k5xo3ll/2cEjrJh55MQjvpNOSZM6BzOF1wjPtGx3M2i+kknPertk7CuJOgk56xgE6S+mUpOmm7eCeJOukGyF83gk7ysVYJeaN8cIybn/M8KPHANRAF4x7j3q2P19lO6hX4sKy+oErtJA9c57WTdjh48vOXQp55uWMMG9cz3lThGDe2VTz0gbOuscJDjrh9fddgEMJFHYXzDHz9VtBJ2PdhOTNunGdHf3jdLd7B8ZJ+B+9ImTeW/wjuOT7KM6+C/HVTFca4+x3y6QX5yHUYrjFu9l+NdhKXSTnGjeWX/bxX6CQferJa7STXuBk//xDkmY+AzuF0wTHumx3P2Symk1h2d4ZOwriToJO+tIBOkvplKTpJzqcmUSd9HPLXzaCTfOyNRt4oHxzj5uc7wW2L8I/jpbgOzIcelToxMu5xMHbDNoLnPdRzzurgsDc7ZCXPTsO9/Gnd8yDfK5jyfg/WozVm/n5I3vsYwX2hQi6uvY+c/nLvI8eH69e/I+owX+dWyDX1rj0H7Od7gMmYuf1t17kVkfDnc+/ENsGjy8GD/dwiZOtjPb6vMkFh4Heiex08+fmPQX//BOp/eUYAPb/N8ZzNYu0DXF/qYTyq1D5gXSrXXGHcvr/FJtsH7I5ttF8v0D5gOTNuPIdkofbBXvEOtg+6HbwjZd5YF0dmfnuG8szPIH/dVoX2QbdDPl0gH5znYiy+6tYIsBTM/P2EWO/jWc+yPvW59xPr/wjuce8nu+F52V3wDhm5R3O9J7wLnT2E33PyFXe9iLu+inE3irgbqxj3Qt+eq0bcrSLu1irG3S7ibq9i3HdOPs+Vvr26yUO4lG74PT0yi7UZ8HsgG9XxZHMtpnym77XF2ftNzxZPZwAXY90ssGbMXNz8vA3cauC6Ft6rM/P5NzjcmhxuLQ63NjPfdMD1GrjuhOv1EAafk+viwX5kOlXD/Y78MV7KV5xX8PsQ/HwjuHG6bAK3WhFes3HgKcT/2ZWZUsEmEEcckdSIuIazh0dGimNDxdxwbiI7NH4sP5odGT12OJ/L50bzo5ND+eHhYn4kPzZ+bHwsO54bGS7mpkbHh6fiyDQbuXm9sLI+OQ8pcr6LImcu1JzZRs35zv3h+H8s/idzgSkrAZbPUPz8AvB31zi8hQqVUZTFuNGVBZu7mXIjqsGBn02t47oJ/GkeqCXjlVg6HTi9KQwMXCvM8Vjw2uHe3egVZF+8766fRl4V2hHFsApGtyJbqkK70Cys0C4Efxc5/GXi5xfF/9SCutjMNdoy18zH97iTZH7JIjK/BPzdcxGZ3xNkfi+Hv/H4+b3if8J1KYRhjK5uudgR7orTJ6OrB7R53yOWqTbvSzJ+9F+tMs57a8pSj3POl/ykLsuuzOQaFdPiPkZXlxFXCjMyZd2yFN12mVlYt10G/i5fZrj3XSTc+4K/+5mFdeb9TFln3n+Z8R9dJP6j4O+KReK/AuK/0iyss680ZZ19FYRBphD/Z1dmSjr7/kZfd12aAp19lQfe906Jzn6AoiwV0zqnKb9qdbwP64WVxdmLB8b/D4r/r47/Hxz/P8TafHyNo5GRFp6R7OFSh79urtzY4Ggd+6G6DL9Qm4nda/Cd2A2/UFpbNyeY81+FjW/wq7r1sRsPRHRCHPUgi3ptWVhp4Egkm8VGxxFPnT6e0ug4jxLT6PiZEyeOTx0vzlxWPHt04vgMjnsw7DoBWw7YyudkahxunkSckwPwEdyjODn5C3pxlw4EbdTnNMLVuzHlhQ+MvxHkzn544HsN8GVTC+GQaRNy4f9GffmUDghr9iSfFiEfxt8M8mE/24V8WhzyaQT5NAl/yKNg1HiUDgRt9SSfNiEf/DA4y0d+pHoNyEDKpxmetQh/yKNgdBdStXuST4eQD+NvB/mwn34hnw6HfFpBJm3CH37oG6s1jgurK1mG8ePfWE2uhfjYrcYRb63gVaomBZ9SNRlf40fbWWdwXF4n0YzRb2fROOvlRr/NfnnC+yoUzgM88L5vSvoqD1WUpWJa5zTlJ8cgiDP1/R8S/z/YlMcWHmaWN2bxcLPwmMXDwd/vxeHd3qYHo52nH2aSXeaOxPIwuuHOmVh9hClXNJ76b8PYf5Pp6uq/YSWTgT5dI74jwusEN+aHfZNT07PHp85y92SSVvEstc8hr2sdbgyrXoSH9PiZ9zrPCDJaYT/C+NHV2mPZOP68Ur3/SEVcPJZNYUZmvv6kL0WRHuyL/7OmrBcfZRbWn48CfxNxeHIFmY/8oLiIJuuAW1HYx/JDx3LF3PjoZHZiyCbk5PDIKA4++JLFAQ+y0MbYlwKMWeMnT2njnDB+6uNjptxh8lQfj2F9LFeVLrU+9jKeOHJ+AMPHoB52PusXGCducLQpGkSbwtMA3aK7Bjg+wsod5/PtmYtnihOz81sz/IKrhYMEybiWHaOybHC8z/4zjnDIkDCbBBbMWPwstS2hYyYdLSFsvay0JXSN0W8JUZiRqd7yVM0a0DW1MWlt0dopM3efKpvIqGnKkUpmxXBPiAftnfOkvYc9ad3bRzzIyGF/nNLgoeqM0S0DTRBuBuJpgqTja9zng/usOJ1xuqHB4Q+v68Q77fC8wcE7Uua90B41jq8e3HB2FZd0+8hnSZxdZT1iZ1ePnjl24vg1dmr1wlOTRydmZo9PnLhwcnKmePq0SxnVCgIL1dh3NM+K4xo4NyFbBq6xDhQoZkpvtb7sI5NGpr5xMf6n3arXmvl96Wvj51PxP01kPFpglLXzSmtUxdoo92i9sEprVmS/wBj92lhRm3rt66VlnMOnDCZTklZFo9s6WB03Cm/cCCtM1vnHrf19M/fUUTaRUWtBT2CrXu7uXerYDE7I14Db7ZU4uN1eiUOc6i3tkexokynzUQs3XreOJ3N56NXkPbU2h1Z7NeXTQYwJo1fDi2aoV9Mkxht9YpP6qklgazHlcefiyeOzl5y6ZubsdXZs8fLpa7GxjnnGCNkiFzJYd+LwYb3jXZSf7DC4zEKdGeLFC5gio1dWSVe6TlZAE8G1ayGbIp6cJ56l+hlPM5EL89rhOZZrD4vqcrjokMNGHDJuxc3dJTl03IEcOhxYOqosB1yY1yawtorn/F8juGAbgv2nbmEeKY9DRn+B2mOMbqbysUjorh54H80kmzeFc28PvK9Q5s1Ge0HiCUVZKqZ17oqE5xteVKedb04aP/lGe0pQk/OplHDOKHKeTgnnGkXO16WEc60i58emhHOdIueZlHCuV+R8OiWcGxQ5z6aEs+ahFGdSwvmgIufHpYRzvyLn6wPkfEOAnM8GyPnxKeH8GEXOT0gJ5xOKnJ+YEs6a9fOTUsJZszw/OUDOTwmQ81MD5Py0ADk/PUDOzwiQ840Bcn5mgJyfFSDnZwfI+TkBcn5ugJyfFyDn5wfI+QUBcn5hgJxfFCDnFwfI+SUBcn5pgJxfFiDnlwfI+RUBcn5lgJxfFSDnVwfI+TUBcn5tgJxfFyDn1wfI+Q0Bcn5jgJzfFCDnNwfI+S0Bcn5rgJxvCpDz2wLk/PYAOb8jQM7vDJDzuwLk/O4AOb8nQM7vDZDz+wLk/P4AOX8gQM4fDJDzhwLk/OEAOX8kQM4fDZDzxwLk/PEAOX8iQM6fDJDzpwLk/OkAOX8mQM6fDZDz51LC+UGKnD+fEs5XK3L+Qko4P1iR8xdTwvkhipy/lBLOE4qcb04JZ83PZX05JZw166qvBMj5DwLk/IcBcv6jADn/cYCc/yRAzn8aIOevBsj5zwLk/LUAOf95gJy/HiDnvwiQ818GyPkbAXL+qwA5/3WAnP8mQM5/GyDnbwbI+VsBcv52gJy/EyDnvwuQ898HyPm7AXL+XoCcvx8g538IkPMPUsL5YYqcf5gSzicVOf8oJZzvo8j5lpRw1izP/xgg538KkPM/B8j5XwLk/OMAOf9rgJx/EiDnfwuQ808D5PyzADn/PEDOtwbI+d8D5PyLADn/R4Cc/zNAzv8VIOf/DpDzLwPk/KsAOf86QM63Bcj5fwLk/L8Bcv5NgJz/L0DOvw2Q87kAOf9/gJxNJjzOmQA51wTIuTZAznUBcq4PkHNDgJwbA+TcFCDn5gA5twTIuTVAzm0Bcm4PkHNHgJzXBMi5M0DOawPkvC5AzusD5LwhQM4bA+S8KUDOmwPk3BUg5y0Bcu4OkPPWlHC+RpHztgDTeXuAnHcEyHlngJyjADnvCpDz7pRwblLk3JMSzs2KnPekhHOLIue9KeHcqsi5NyWc2xQ570sJ53ZFzvtTwrlDkfOBlHBeo8i5LyWcOxU596eE81pFzgMp4bxOkfPBlHBer8h5MCWcNyhyPpQSzhsVOWdTwnmTIudcSjhvVuQ8lBLOXYqch1PCeYsi55GUcO5W5DyaEs5bFTkfTgnnbYqcx1LCebsi53xKOO9Q5DyeEs47FTnfJSWcI0XOR1LCeZci5wtSwnm3Iue7poRzjyLnu6WE8x5FzndPCee9ipwLKeHcq8j5wpRw3qfI+aKUcN6vyPliRc42KFMbh9UP/DOxDOhZnbX11jZY22gtzaXT3DLNtdLcI83F0dwUzdXQ3AWN5dPYNo310tgnjQXS2BiNFdHYCY0lUN+a+prU96K+CLXNqa1KbbfIWqrbqa4j3U+6kHQDlRXKOyTLA9b2Ad5vxf+nrJ229jprH2vtjLWnrZ219oy1j7P2emtvsPastY+39gnWPtHaJ1n7ZGufYu1TrX2atU+39hnW3mjtM619lrXPtvY51j7X2udZ+3xrX2DtC619kbUvtvYl1r7U2pdZ+3JrX2HtK619lbWvtvY11r7W2tdZ+3pr32DtG619k7VvtvYt1r7V2pusfZu1b7f2Hda+09p3Wftua99j7XutfZ+177f2A9Z+0NoPWfthaz9i7Uet/Zi1H7f2E9Z+0tpPWftpaz9j7Wet/Zy1n7f2C9Z+0dovWXuztV+29ivW0vfG6fvb9D1q+j4zfa+Yvt9L37Ol77t+zVr6/id9D5O+D0nfS/yGtfQ9Pfq+HH1vjb4/9s04neh7TfT9IvqeD33fhr73Qt8/oe+B0Pcx6HsRP7T2R9beYi2dN0/nr9N55HQ+N51XTec303nGdL7vT62l81/pPFQ6H5TOy/yFtXSeIp0vSOft0flzdB4bnU9G53XR+VV0nhOdb0Tn/dD5N3QeDJ2PQueFUAGg8yTofAU6b4D239N+dNqfTfuVaf8u7Wel/Z2035H2/9F+ONofRvulaP8Q7aeh/SW034L2H9B6fFqfTuu1af0yreel9a203pPWP9J6QFofR+vFaP0UrSei9TW03oTWX9B6BJqfp/lqmr+l+Uya36P5Lpr/ofkQmh+g8XIq2DSeSuOLNN5G4080HkPjE9Rfp/4r9eeof0PtfWr/UnuQ2kel9oK1VJ+QfiV9Q2WPzeb4/4L4/6rZ6ZmJa4vR6RPTs1E2OmV/J06cmL6+ODkY4bPT0ckzp2ej07MTM7PR1Mz0ySg3SO8PxuFsi/8nZmeLJ6+bjWano4nJyej647OPjqYfV5yZsmHS80uW6f+yZfgnvdcV+6N0J7Mlvr9wZmbibHT81GTxhmj6zGw0PRUdmz5zavI0vtRSyUtrK3mpq5KXdlbyUm8lLx2s5KWRSl7qqakEXiUvXRa/tCu+h5x08syJ2ePXnTi7cHa6Mn55udnwQZUgfWSFkV1TSWSnKozszZVE9s5KXvpAJS99u5KXflnJS+trK3gpV8lL96/kpZOVvPT8Sl56TyUvfTt+abnZ77uVRPaj5bx0JPa00VTw0rZKXuqp5KW+pb5kfgfFHA5fk9oBAA==","debug_symbols":"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"},{"name":"constructor","function_type":"Secret","is_internal":false,"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"private_global_variables","type":{"kind":"struct","path":"aztec::context::globals::private_global_variables::PrivateGlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]}}]},"visibility":"private"},{"name":"number","type":{"kind":"field"},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"inputs":[{"start":0,"end":41}],"number":[{"start":41,"end":42}],"owner":[{"start":42,"end":43}]},"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"is_contract_deployment","type":{"kind":"boolean"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"return_values","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_key_validation_requests","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier_key_validation_request::NullifierKeyValidationRequest","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_private_key::GrumpkinPrivateKey","fields":[{"name":"high","type":{"kind":"field"}},{"name":"low","type":{"kind":"field"}}]}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffect","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::SideEffectLinkedToNoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"note_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"private_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":4,"type":{"kind":"field"}}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}}]}}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"encrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"unencrypted_logs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"encrypted_log_preimages_length","type":{"kind":"field"}},{"name":"unencrypted_log_preimages_length","type":{"kind":"field"}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"in_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}},{"name":"out_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"field"}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}},{"name":"contract_deployment_data","type":{"kind":"struct","path":"aztec::protocol_types::contrakt::contract_deployment_data::ContractDeploymentData","fields":[{"name":"public_key","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"initialization_hash","type":{"kind":"field"}},{"name":"contract_class_id","type":{"kind":"struct","path":"aztec::protocol_types::contract_class_id::ContractClassId","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address_salt","type":{"kind":"field"}},{"name":"portal_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}}]},"visibility":"public"},"return_witnesses":[67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280]},"bytecode":"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","debug_symbols":"3ZjbjhoxDED/ZZ4Rii+JbX6l2gfaUgkJsasFVaoQ/94Z2GQCTSftILEMT7sj2ebE8TWHZvP6bblfv253zeLQADSLL4dm97bcdp+7/fJ93yzcrFltv7d/j7Pmx3qzahYcjrM/xMDbhyAoJFEAKsgiSbSKjNJLm5UsAwNF28ByKf8yawAnyk334vaOI7cPfDM338DNQlGyNd0LB19CcQ4jicPsmKol0xaF/cXl8AnaTxE6TBFaStAeY7x6r8PgaOJjuFoW3Ahn+1q0HzTaVz9s3ziaN+tRwIVRyWCPRIPuRhpw0v8AuQrPP0ai+hguGiwzebpOhOkh4/SQaXrIPIwcwIatk3MRmRzjhf1C1WHQ1CTRKtL1TPQ30yfnkLMaPTNFy8wh5MW+gwmPBCO3wkB/r+0YVIFRjrOPag/usRQCzmKTQsC+GPvSUKUpH8z5YVFAgBgr6PGioY0JLX0KB1oIaeKAUPFg1Sd2V5+0VU8TjlnulRaG3KfBtG6/hoH7wiD6BBN0OF7YWRpRAfSqUBBOlpzuTG4pAIipkqOM/RLLoVKMWCOHp77KyalBEz/LKQViiZNMVrg4rktKfJev0n5M2SL/LC4MaSWU7IWh6EKwtGuiy9phtz+O8WF4mjCUGFvq5DrZ5JFP6WMrxyBQOSVJegnIRgSW89vBvJgRaayArL+pO3f+ORT7LSqlYUQDXT8jdHowUq/cmNKcFKiHbN1xagjz8kMBcXQzZdv/x5XTvLzP15RgjBKOUaL/VpL5XzYjit7zgldR0SmFMUrFnAnpWUxdH6uix5f24+fyfb38ull1D+Lt5/7X2/nf428="},{"name":"getNumber","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"param_witnesses":{"owner":[{"start":0,"end":1}]},"return_type":{"abi_type":{"kind":"struct","path":"value_note::value_note::ValueNote","fields":[{"name":"value","type":{"kind":"field"}},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"randomness","type":{"kind":"field"}},{"name":"header","type":{"kind":"struct","path":"aztec::note::note_header::NoteHeader","fields":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}},{"name":"storage_slot","type":{"kind":"field"}},{"name":"is_transient","type":{"kind":"boolean"}}]}}]},"visibility":"public"},"return_witnesses":[1,2,3,4,5,6,7]},"bytecode":"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","debug_symbols":"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2Wsze21mr83stZm9NrPXZvbazF6b2Wsze21mr83stZm9NrPXZvbazF6b2Wsze21mr83stZm9NrPXZvbazF6b2Wsze21mr83stZm9NrPXZvbazF6b2Wsze21mr83stZm9NrPXZvbazF6b2Wsze21mr83stZm9NrPXZvbazF6b2Wsze21mr83stZm9NrPXZvbazF6b2Wsze21mr83stZm9NrPXZvbazF6b2Wsze21mr83stZm9NrPXZvbazF6b2Wsze21mr83stZm9NrPXZvbazF6b2Wsze21mr83stZm9NrPXZvY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8PsdZi9DrPXYfY6zF6H2eswex1mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfa6zF6X2esye11mr8vsdZm9LrPXZfZ6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxez1mr8fs9Zi9HrPXY/Z6zF6P2esxe73XhJT5ePySy4z9ytkjv4JFg02DQ4NLgweDrznp9wSNBp0GgwZpc5I2J2lzkjYnaXOSNqdoc4o2p2hzijanaHOKNqdoc4o2p2hzijanaXOaNqdpc5o2p2lzmjanaXOaNqdp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wedvofMVLPuRe+1yvyNnMOcwFzCXMFcw1zA3MLcwB/uysC8L+7KwLwv7srAvC/uysC8L+7KwLwv7crAvB/tysC8H+3KwLwf7crAvB/tysC/H+jKPB8wZzDnMBcwlzBXMNcwNzC3Mwb4Y7IvBvhjsi8G+GOyLwb4Y7IvBvhjsi8G+OOyLw7447IvDvjjsi8O+OOyLw7447IvDvgTsS8C+BOxLwL4E7EvAvgTsS8C+BOxLwL4k7EvCviTsS8K+JOxLwr4k7EvCviTsS8K+FOxLwb4U7EvBvhTsS8G+FOxLwb4U7EvBvjTsS8O+NOxLw7407EvDvjTsS8O+NOwL9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313oO8O9N2BvjvQdwf67kDfHei7A313vvHdjK9chr3KBcwlzBXMNcwNzC3MHcrtN77785zB3Dd9SfuRe14Jr3IBcwlzBXMNcwNzC3PHct/47s9zBnOwLwb7YrAvBvtisC8G+2KwLwb74rAvDvvisC8O++KwLw774rAvDvvisC8O+xKwLwH7ErAvAfsSsC8B+xKwLwH7ErAvAfuSsC8J+5KwLwn7krAvCfuSsC8J+5KwLwn7UrAvBftSsC8F+1KwLwX7UrAvBftSsC8F+9KwLw370rAvDfvSsC8N+9KwLw370rAvDfsysC8D+zKwLwP7MrAvA/sysC8D+zKwLwP7srAvC/uysC8L+7KwLwv7srAvC/uysC8L+3KwLwf7crAvB/tysC8H+3KwLwf7crAvx/pyjwfMGcw5zAXMJcwVzDXMDcwtzMG+QN896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd895rvxYL77zBnMOcwFzCXMFcw1zA3MLczBvhjsi8G+GOyLwb4Y7IvBvhjsi8G+GOyLwb44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B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN8d6LsDfXeg7w703YG+O9B3B/ruQN9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YW+u9B3F/ruQt9d6LsLfXeh7y703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruQd896LsHffeg7x703YO+e9B3D/ruMd/NB/PdZ85gzmEuYC5hrmCuYW5gbmEO9sVgXwz2xWBfDPbFYF8M9sVgXwz2xWBfDPbFYV8c9sVhXxz2xWFfHPbFYV8c9sVhXxz2JWBfAvYlYF8C9iVgXwL2JWBfAvYlYF8C9iVhXxL2JWFfEvYlYV8S9iVhXxL2JWFfEvalYF8K9qVgXwr2pWBfCval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"},{"name":"compute_note_hash_and_nullifier","function_type":"Unconstrained","is_internal":false,"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"}],"param_witnesses":{"contract_address":[{"start":0,"end":1}],"nonce":[{"start":1,"end":2}],"note_type_id":[{"start":3,"end":4}],"serialized_note":[{"start":4,"end":24}],"storage_slot":[{"start":2,"end":3}]},"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"return_witnesses":[24,25,26,27]},"bytecode":"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","debug_symbols":"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"}],"events":[],"file_map":{"3":{"source":"struct BoundedVec<T, MaxLen> {\n    storage: [T; MaxLen],\n    len: u64,\n}\n\nimpl<T, MaxLen> BoundedVec<T, MaxLen> {\n    pub fn new() -> Self {\n        let zeroed = crate::unsafe::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    pub fn get(mut self: Self, index: u64) -> T {\n        assert(index as u64 < self.len);\n        self.storage[index]\n    }\n\n    pub fn get_unchecked(mut self: Self, index: u64) -> T {\n        self.storage[index]\n    }\n\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen as u64, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    pub fn len(self) -> u64 {\n        self.len\n    }\n\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u64 {\n        MaxLen\n    }\n\n    // This is a intermediate method, while we don't have an\n    // .extend method\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    pub fn extend_from_array<Len>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    pub fn extend_from_bounded_vec<Len>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len as u64 <= MaxLen as u64, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    pub fn pop(&mut self) -> T {\n        assert(self.len as u64 > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::unsafe::zeroed();\n        elem\n    }\n\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"34":{"source":"struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n","path":"std/option.nr"},"46":{"source":"contract BoxReact {\n    use dep::aztec::{\n        protocol_types::address::AztecAddress, state_vars::{PrivateMutable, Map},\n        note::{utils as note_utils, note_interface::NoteInterface, note_header::NoteHeader}\n    };\n\n    use dep::value_note::value_note::{ValueNote, VALUE_NOTE_LEN};\n\n    struct Storage {\n        numbers: Map<AztecAddress, PrivateMutable<ValueNote>>,\n    }\n\n    #[aztec(private)]\n    fn constructor(number: Field, owner: AztecAddress) {\n        let numbers = storage.numbers;\n        let mut new_number = ValueNote::new(number, owner);\n        numbers.at(owner).initialize(&mut new_number, true);\n    }\n\n    #[aztec(private)]\n    fn setNumber(number: Field, owner: AztecAddress) {\n        let numbers = storage.numbers;\n        let mut new_number = ValueNote::new(number, owner);\n        numbers.at(owner).replace(&mut new_number, true);\n    }\n\n    unconstrained fn getNumber(owner: AztecAddress) -> pub ValueNote {\n        let numbers = storage.numbers;\n        numbers.at(owner).view_note()\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/boxes/boxes/react/src/contracts/src/main.nr"},"47":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::oracle;\nuse dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint};\n\npub fn emit_encrypted_log<N>(\n    context: &mut PrivateContext,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    log: [Field; N]\n) {\n    let _ = oracle::logs::emit_encrypted_log(\n        contract_address,\n        storage_slot,\n        note_type_id,\n        encryption_pub_key,\n        log\n    );\n    context.accumulate_encrypted_logs(log);\n}\n\npub fn emit_unencrypted_log<T>(context: &mut PublicContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n\n// TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n// --> might be a better approach to force devs to make a public function call that emits the log if needed then\n// it would be less easy to accidentally leak information.\n// If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\npub fn emit_unencrypted_log_from_private<T>(context: &mut PrivateContext, log: T) {\n    let contract_address = context.this_address();\n    let event_selector = 5; // TODO: compute actual event selector.\n    let _ = oracle::logs::emit_unencrypted_log(contract_address, event_selector, log);\n    // context.accumulate_unencrypted_logs(log);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/log.nr"},"51":{"source":"use dep::std::option::Option;\nuse dep::protocol_types::{\n    constants::{\n    MAX_READ_REQUESTS_PER_CALL, GET_NOTE_ORACLE_RETURN_LENGTH, GET_NOTES_ORACLE_RETURN_LENGTH,\n    MAX_NOTES_PER_PAGE, VIEW_NOTE_ORACLE_RETURN_LENGTH\n}\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, Comparator, NoteStatus},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_consumption\n};\nuse crate::oracle;\n\nfn check_note_header<Note, N>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address));\n    assert(header.storage_slot == storage_slot);\n}\n\nfn check_note_fields<N>(fields: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n\n        // Values are computed ahead of time because circuits evaluate all branches\n        let isEqual = fields[select.field_index] == select.value;\n        let isLt = fields[select.field_index].lt(select.value);\n\n        if (select.comparator == Comparator.EQ) {\n            assert(isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.NEQ) {\n            assert(!isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LT) {\n            assert(isLt, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.LTE) {\n            assert(isLt | isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GT) {\n            assert(!isLt & !isEqual, \"Mismatch return note field.\");\n        } else if (select.comparator == Comparator.GTE) {\n            assert(!isLt, \"Mismatch return note field.\");\n        }\n    }\n}\n\nfn check_notes_order<N>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let eq = fields_0[sort.field_index] == fields_1[sort.field_index];\n        let lt = fields_0[sort.field_index].lt(fields_1[sort.field_index]);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> Note where Note: NoteInterface<N> {\n    let note = get_note_internal(storage_slot);\n\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n\n    context.push_read_request(note_hash_for_read_request);\n    note\n}\n\npub fn get_notes<Note, N, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let opt_notes = get_notes_internal(storage_slot, options);\n    let mut num_notes = 0;\n    let mut prev_fields = [0; N];\n    for i in 0..opt_notes.len() {\n        let opt_note = opt_notes[i];\n        if opt_note.is_some() {\n            let note = opt_note.unwrap_unchecked();\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_consumption(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_read_request(note_hash_for_read_request);\n\n            num_notes += 1;\n        };\n    }\n    if options.limit != 0 {\n        assert(num_notes <= options.limit, \"Invalid number of return notes.\");\n    }\n    opt_notes\n}\n\nunconstrained fn get_note_internal<Note, N>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].unwrap() // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, N, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, FILTER_ARGS>\n) -> [Option<Note>; MAX_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let filter = options.filter;\n    let filter_args = options.filter_args;\n    filter(opt_notes, filter_args)\n}\n\nunconstrained pub fn view_notes<Note, N>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> [Option<Note>; MAX_NOTES_PER_PAGE] where Note: NoteInterface<N> {\n    let (num_selects, select_by, select_values, select_comparators, sort_by, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    )\n}\n\nunconstrained fn flatten_options<Note, N>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [Field; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by[num_selects] = select.unwrap_unchecked().field_index;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by[i] = sort.unwrap_unchecked().field_index;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (num_selects, select_by, select_values, select_comparators, sort_by, sort_order)\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_getter.nr"},"52":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::NoteInterface,\n    utils::{compute_note_hash_for_insertion, compute_note_hash_for_consumption}\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, N>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n    broadcast: bool\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    // As `is_transient` is true, this will compute the inner note hsah\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    // TODO: Strong typing required because of https://github.com/noir-lang/noir/issues/4088\n    let serialized_note: [Field; N] = Note::serialize_content(*note);\n    assert(\n        notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        inner_note_hash\n    )\n        == 0\n    );\n\n    context.push_new_note_hash(inner_note_hash);\n\n    if broadcast {\n        Note::broadcast(*note, context, storage_slot);\n    }\n}\n\npub fn create_note_hash_from_public<Note, N>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> {\n    let contract_address = (*context).this_address();\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, is_transient: true };\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    Note::set_header(note, header);\n    let inner_note_hash = compute_note_hash_for_insertion(*note);\n\n    context.push_new_note_hash(inner_note_hash);\n}\n\npub fn destroy_note<Note, N>(context: &mut PrivateContext, note: Note) where Note: NoteInterface<N> {\n    let mut nullifier = 0;\n    let mut consumed_note_hash: Field = 0;\n    nullifier = note.compute_nullifier(context);\n\n    // We also need the note hash corresponding to the \"nullifier\"\n    let header = note.get_header();\n    // `consumed_note_hash` is used to inform the kernel which pending note hash\n    // the nullifier corresponds to so they can be matched and both squashed/deleted.\n    // nonzero nonce implies \"persistable\" nullifier (nullifies a persistent/in-tree\n    // note hash) in which case `consumed_note_hash` is not used since the kernel\n    // just siloes and forwards the nullifier to its output.\n    if (header.is_transient) {\n        // TODO(1718): Can we reuse the note hash computed in `compute_nullifier`?\n        consumed_note_hash = compute_note_hash_for_consumption(note);\n    }\n    assert(notify_nullified_note(nullifier, consumed_note_hash) == 0);\n\n    context.push_new_nullifier(nullifier, consumed_note_hash)\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"53":{"source":"use crate::{context::PrivateContext, note::{note_header::NoteHeader, note_interface::NoteInterface}};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__SILOED_NOTE_HASH},\n    hash::pedersen_hash, utils::arr_copy_slice\n};\n\nfn compute_siloed_hash(contract_address: AztecAddress, inner_note_hash: Field) -> Field {\n    let inputs = [contract_address.to_field(), inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__SILOED_NOTE_HASH)\n}\n\nfn compute_unique_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\nfn compute_inner_note_hash<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let note_hash = note.compute_note_content_hash();\n\n    // TODO(#1205) Do we need a generator index here?\n    pedersen_hash([header.storage_slot, note_hash], 0)\n}\n\nfn compute_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let inner_note_hash = compute_inner_note_hash(note_with_header);\n\n    compute_siloed_hash(header.contract_address, inner_note_hash)\n}\n\nfn compute_unique_siloed_note_hash<Note, N>(note_with_header: Note) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n\n    let siloed_note_hash = compute_siloed_note_hash(note_with_header);\n\n    compute_unique_hash(header.nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_nullifier<Note, N>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> {\n    let header = note_with_header.get_header();\n    let inner_nullifier = note_with_header.compute_nullifier(context);\n\n    let input = [header.contract_address.to_field(), inner_nullifier];\n    pedersen_hash(input, GENERATOR_INDEX__OUTER_NULLIFIER)\n}\n\npub fn compute_note_hash_for_insertion<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    compute_inner_note_hash(note)\n}\n\npub fn compute_note_hash_for_consumption<Note, N>(note: Note) -> Field where Note: NoteInterface<N> {\n    let header = note.get_header();\n    // There are 3 cases for reading a note intended for consumption:\n    // 1. The note was inserted in this transaction, and is transient.\n    // 2. The note was inserted in a previous transaction, and was inserted in public\n    // 3. The note was inserted in a previous transaction, and was inserted in private\n\n    if (header.is_transient) {\n        // If a note is transient, we just read the inner_note_hash (kernel will silo by contract address).\n        compute_inner_note_hash(note)\n    } else if (header.nonce == 0) {\n        // If not transient and nonce is zero, that means we are reading a public note.\n        compute_siloed_note_hash(note)\n    } else {\n        // When nonce is nonzero, that means we are reading a settled note (from tree) created in a\n        // previous TX. So we need the unique_siloed_note_hash which has already been hashed with\n        // contract address and then nonce. This hash will match the existing leaf in the private\n        // data tree, so the kernel can just perform a membership check directly on this hash/leaf.\n        compute_unique_siloed_note_hash(note)\n        // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n        // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n        // nullification, it is not strictly necessary to silo the note hash before computing\n        // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n        // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n        // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n        // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n        // nullifiers are computed from a note hash's fully-computed private data tree leaf.\n    }\n}\n\npub fn compute_note_hash_and_nullifier<T, N, S>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n    T::set_header((&mut note), note_header);\n\n    let inner_note_hash = compute_inner_note_hash(note);\n\n    let siloed_note_hash = compute_siloed_hash(note_header.contract_address, inner_note_hash);\n\n    let unique_siloed_note_hash = compute_unique_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = note.compute_nullifier_without_context();\n\n    [inner_note_hash, siloed_note_hash, unique_siloed_note_hash, inner_nullifier]\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"65":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, interface::ContextInterface},\n    key::nullifier_key::validate_nullifier_key_against_address,\n    messaging::process_l1_to_l2_message,\n    oracle::{\n    arguments, call_private_function::call_private_function_internal,\n    enqueue_public_function_call::enqueue_public_function_call_internal, context::get_portal_address,\n    header::get_header_at, nullifier_key::{get_nullifier_key_pair, NullifierKeyPair},\n    debug_log::debug_log\n}\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext, function_data::FunctionData, function_selector::FunctionSelector,\n        nullifier_key_validation_request::NullifierKeyValidationRequest,\n        private_call_stack_item::PrivateCallStackItem,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_stack_item::PublicCallStackItem,\n        public_circuit_public_inputs::PublicCircuitPublicInputs,\n        side_effect::{SideEffect, SideEffectLinkedToNoteHash}\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_PUBLIC_DATA_READS_PER_CALL, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL,\n    MAX_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL, NUM_FIELDS_PER_SHA256,\n    RETURN_VALUES_LENGTH\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, hash::hash_args, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::is_empty\n};\nuse dep::std::option::Option;\n\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n// use dep::std::collections::vec::Vec;\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n\n    args_hash : Field,\n    return_values : BoundedVec<Field, RETURN_VALUES_LENGTH>,\n\n    read_requests: BoundedVec<SideEffect, MAX_READ_REQUESTS_PER_CALL>,\n    nullifier_key_validation_requests: BoundedVec<NullifierKeyValidationRequest, MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<SideEffect, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<SideEffectLinkedToNoteHash, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_stack_hashes : BoundedVec<Field, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    // encrypted_logs_preimages: Vec<Field>,\n    // unencrypted_logs_preimages: Vec<Field>,\n\n    nullifier_key: Option<NullifierKeyPair>,\n}\n\nimpl ContextInterface for PrivateContext {\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn this_portal_address(self) -> EthAddress {\n        self.inputs.call_context.portal_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.private_global_variables.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.private_global_variables.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        let side_effect = SideEffect { value: note_hash, counter: self.side_effect_counter };\n        self.new_note_hashes.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_commitment: Field) {\n        let side_effect = SideEffectLinkedToNoteHash { value: nullifier, note_hash: nullified_commitment, counter: self.side_effect_counter };\n        self.new_nullifiers.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let side_effect_counter = inputs.call_context.start_side_effect_counter;\n        let mut min_revertible_side_effect_counter = 0;\n        if is_empty(inputs.call_context.msg_sender) {\n            min_revertible_side_effect_counter = side_effect_counter;\n        }\n        PrivateContext {\n            inputs,\n            side_effect_counter,\n            min_revertible_side_effect_counter,\n            args_hash,\n            return_values: BoundedVec::new(),\n            read_requests: BoundedVec::new(),\n            nullifier_key_validation_requests: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_stack_hashes: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n            // encrypted_logs_preimages: Vec::new(),\n            // unencrypted_logs_preimages: Vec::new(),\n            nullifier_key: Option::none()\n        }\n    }\n\n    pub fn is_deployment(self) -> bool {\n        // TODO(#4738): Implement this\n        false\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n        let encrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let unencrypted_logs_hash = [0; NUM_FIELDS_PER_SHA256];\n        let encrypted_log_preimages_length = 0;\n        let unencrypted_log_preimages_length = 0;\n\n        let priv_circuit_pub_inputs = PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            return_values: self.return_values.storage,\n            // TODO(fees): start this from 0 and test the following:\n            // - in the private circuit init that it gets set correctly\n            // - in the private circuit inner that it remains 0\n            // I've had to initialize the counter here so that it would work for contract deployments\n            // the above checks should be doable after we figure out fee payments for contract deployments\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            read_requests: self.read_requests.storage,\n            nullifier_key_validation_requests: self.nullifier_key_validation_requests.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_stack_hashes: self.private_call_stack_hashes.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            end_side_effect_counter: self.side_effect_counter,\n            encrypted_logs_hash,\n            unencrypted_logs_hash,\n            encrypted_log_preimages_length,\n            unencrypted_log_preimages_length,\n            historical_header: self.historical_header,\n            contract_deployment_data: self.inputs.contract_deployment_data,\n            chain_id: self.inputs.private_global_variables.chain_id,\n            version: self.inputs.private_global_variables.version\n        };\n        priv_circuit_pub_inputs\n    }\n\n    pub fn capture_min_revertible_side_effect_counter(&mut self) {\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    pub fn push_read_request(&mut self, read_request: Field) {\n        let side_effect = SideEffect { value: read_request, counter: self.side_effect_counter };\n        self.read_requests.push(side_effect);\n        self.side_effect_counter = self.side_effect_counter + 1;\n    }    \n\n    pub fn request_nullifier_secret_key(&mut self, account: AztecAddress) -> GrumpkinPrivateKey {\n        let key_pair = if self.nullifier_key.is_none() {\n            let key_pair = get_nullifier_key_pair(account);\n            validate_nullifier_key_against_address(account, key_pair.public_key);\n            let request = NullifierKeyValidationRequest { public_key: key_pair.public_key, secret_key: key_pair.secret_key };\n            self.nullifier_key_validation_requests.push(request);\n            self.nullifier_key = Option::some(key_pair);\n            key_pair\n        } else {\n            let key_pair = self.nullifier_key.unwrap_unchecked();\n            // If MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL is larger than 1, need to update the way the key pair is cached.\n            assert(MAX_NULLIFIER_KEY_VALIDATION_REQUESTS_PER_CALL == 1);\n            assert(\n                key_pair.account == account, \"Cannot query nullifier key for more than one account per call\"\n            );\n            key_pair\n        };\n        key_pair.secret_key\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, msg_key: Field, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            msg_key,\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn accumulate_encrypted_logs<N>(&mut self, log: [Field; N]) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn accumulate_unencrypted_logs<T>(&mut self, log: T) {\n        let _void1 = self.inputs;\n        let _void2 = log;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1165)\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> [Field; RETURN_VALUES_LENGTH] {\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        self.side_effect_counter = item.public_inputs.end_side_effect_counter + 1;\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.private_call_stack_hashes.push(item.hash());\n\n        item.public_inputs.return_values\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args(args);\n        assert(args_hash == arguments::pack_arguments(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let mut reader = Reader::new(fields);\n\n        // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n        // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n        let item = PublicCallStackItem {\n            contract_address: AztecAddress::from_field(reader.read()),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: PublicCircuitPublicInputs {\n                call_context: reader.read_struct(CallContext::deserialize),\n                args_hash: reader.read(),\n                return_values: [0; RETURN_VALUES_LENGTH],\n                contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n                contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n                public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n                new_note_hashes: [SideEffect::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n                new_nullifiers: [SideEffectLinkedToNoteHash::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n                new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n                unencrypted_logs_hash: [0; NUM_FIELDS_PER_SHA256],\n                unencrypted_log_preimages_length: 0,\n                historical_header: Header::empty(),\n                prover_address: AztecAddress::zero()\n            },\n            is_execution_request: true\n        };\n        reader.finish();\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.start_side_effect_counter, self.side_effect_counter);\n        // We increment the sideffect counter by one, to account for the call itself being a side effect.\n        self.side_effect_counter = self.side_effect_counter + 1;\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n        assert(item.public_inputs.call_context.is_contract_deployment == false);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        self.public_call_stack_hashes.push(item.hash());\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"71":{"source":"use dep::std::option::Option;\nuse crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n#[oracle(notifyCreatedNote)]\nfn notify_created_note_oracle<N>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _inner_note_hash: Field\n) -> Field {}\n\nunconstrained pub fn notify_created_note<N>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    inner_note_hash: Field\n) -> Field {\n    notify_created_note_oracle(storage_slot, note_type_id, serialized_note, inner_note_hash)\n}\n\n#[oracle(notifyNullifiedNote)]\nfn notify_nullified_note_oracle<N>(_nullifier: Field, _inner_note_hash: Field) -> Field {}\n\nunconstrained pub fn notify_nullified_note<N>(nullifier: Field, inner_note_hash: Field) -> Field {\n    notify_nullified_note_oracle(nullifier, inner_note_hash)\n}\n\n#[oracle(getNotes)]\nfn get_notes_oracle<N, S>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<N, S>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, N, M, S, NS>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by,\n        select_values,\n        select_comparators,\n        sort_by,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u64;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u64 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u64 = 2; // nonce & is_transient.\n            let read_offset: u64 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let is_transient = fields[read_offset + 1] as bool;\n            let header = NoteHeader { contract_address, nonce, storage_slot, is_transient };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            // TODO: change this to note.setHeader(header) once https://github.com/noir-lang/noir/issues/4095 is fixed\n            Note::set_header(&mut note, header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n#[oracle(checkNullifierExists)]\nfn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"74":{"source":"use dep::protocol_types::{address::{AztecAddress, PartialAddress, PublicKeysHash}, grumpkin_point::GrumpkinPoint};\n\n#[oracle(getPublicKeyAndPartialAddress)]\nfn get_public_key_and_partial_address_oracle(_address: AztecAddress) -> [Field; 3] {}\n\nunconstrained fn get_public_key_and_partial_address_internal(address: AztecAddress) -> [Field; 3] {\n    get_public_key_and_partial_address_oracle(address)\n}\n\npub fn get_public_key(address: AztecAddress) -> GrumpkinPoint {\n    let result = get_public_key_and_partial_address_internal(address);\n    let pub_key = GrumpkinPoint::new(result[0], result[1]);\n    let partial_address = PartialAddress::from_field(result[2]);\n\n    let calculated_address = AztecAddress::compute(PublicKeysHash::compute(pub_key), partial_address);\n    assert(calculated_address.eq(address));\n\n    pub_key\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_public_key.nr"},"78":{"source":"use dep::protocol_types::{address::AztecAddress, constants::NUM_FIELDS_PER_SHA256, grumpkin_point::GrumpkinPoint};\n\n// TODO: Should take encrypted data.\n#[oracle(emitEncryptedLog)]\nfn emit_encrypted_log_oracle<N>(\n    _contract_address: AztecAddress,\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _encryption_pub_key: GrumpkinPoint,\n    _preimage: [Field; N]\n) -> Field {}\n\nunconstrained pub fn emit_encrypted_log<N>(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    encryption_pub_key: GrumpkinPoint,\n    preimage: [Field; N]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    [\n        emit_encrypted_log_oracle(\n            contract_address,\n            storage_slot,\n            note_type_id,\n            encryption_pub_key,\n            preimage\n        ), 0\n    ]\n}\n\n#[oracle(emitUnencryptedLog)]\nfn emit_unencrypted_log_oracle<T>(\n    _contract_address: AztecAddress,\n    _event_selector: Field,\n    _message: T\n) -> Field {}\n\nunconstrained pub fn emit_unencrypted_log<T>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    message: T\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // https://github.com/AztecProtocol/aztec-packages/issues/885\n    [emit_unencrypted_log_oracle(contract_address, event_selector, message), 0]\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"},"80":{"source":"#[oracle(getRandomField)]\nfn rand_oracle() -> Field {}\n\nunconstrained pub fn rand() -> Field {\n    rand_oracle()\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/rand.nr"},"83":{"source":"use dep::protocol_types::{address::AztecAddress, grumpkin_point::GrumpkinPoint, grumpkin_private_key::GrumpkinPrivateKey};\n\nstruct NullifierKeyPair {\n    account: AztecAddress,\n    public_key: GrumpkinPoint,\n    secret_key: GrumpkinPrivateKey,\n}\n\n#[oracle(getNullifierKeyPair)]\nfn get_nullifier_key_pair_oracle(_account: AztecAddress) -> [Field; 4] {}\n\nunconstrained fn get_nullifier_key_pair_internal(account: AztecAddress) -> NullifierKeyPair {\n    let result = get_nullifier_key_pair_oracle(account);\n    NullifierKeyPair {\n        account,\n        public_key: GrumpkinPoint { x: result[0], y: result[1] },\n        secret_key: GrumpkinPrivateKey { high: result[2], low: result[3] }\n    }\n}\n\npub fn get_nullifier_key_pair(account: AztecAddress) -> NullifierKeyPair {\n    get_nullifier_key_pair_internal(account)\n}\n\npub fn get_nullifier_secret_key(account: AztecAddress) -> GrumpkinPrivateKey {\n    get_nullifier_key_pair_internal(account).secret_key\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/nullifier_key.nr"},"91":{"source":"mod globals;\nmod inputs;\n\nmod private_context;\nmod public_context;\nmod interface;\nmod avm;\n\nuse private_context::PrivateContext;\nuse interface::ContextInterface;\nuse public_context::PublicContext;\nuse avm::AVMContext;\n\nstruct Context {\n    private: Option<&mut PrivateContext>,\n    public: Option<&mut PublicContext>,\n}\n\nimpl Context {\n    pub fn private(context: &mut PrivateContext) -> Context {\n        Context { private: Option::some(context), public: Option::none() }\n    }\n\n    pub fn public(context: &mut PublicContext) -> Context {\n        Context { public: Option::some(context), private: Option::none() }\n    }\n\n    pub fn none() -> Context {\n        Context { public: Option::none(), private: Option::none() }\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/context.nr"},"104":{"source":"use dep::std::option::Option;\n\nuse dep::protocol_types::{address::AztecAddress, constants::{GENERATOR_INDEX__INITIALIZATION_NULLIFIER}, hash::pedersen_hash};\n\nuse crate::context::{PrivateContext, PublicContext, Context};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note}, note_getter::{get_note, view_notes},\n    note_interface::NoteInterface, note_viewer_options::NoteViewerOptions\n};\nuse crate::oracle::{nullifier_key::get_nullifier_secret_key, notes::check_nullifier_exists};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\nstruct PrivateMutable<Note> {\n    context: Option<&mut PrivateContext>,\n    storage_slot: Field\n}\n// docs:end:struct\n\nimpl<T> Storage<T> for PrivateMutable<T> {}\n\nimpl<Note> PrivateMutable<Note> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context: context.private, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateMutable>` type (for example), because the storage slot often also identifies an actor. e.g.\n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy.\n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        pedersen_hash(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // docs:start:initialize\n    pub fn initialize<N>(self, note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        context.push_new_nullifier(nullifier, 0);\n\n        create_note(context, self.storage_slot, note, broadcast);\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace<N>(self, new_note: &mut Note, broadcast: bool) where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n        let prev_note = get_note(context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note(context, prev_note);\n\n        // Add replacement note.\n        create_note(context, self.storage_slot, new_note, broadcast);\n    }\n    // docs:end:replace\n\n    // docs:start:get_note\n    pub fn get_note<N>(self, broadcast: bool) -> Note where Note: NoteInterface<N> {\n        let context = self.context.unwrap();\n        let mut note = get_note(context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note(context, note);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(context, self.storage_slot, &mut note, broadcast);\n\n        note\n    }\n    // docs:end:get_note\n\n    // docs:start:view_note\n    unconstrained pub fn view_note<N>(self) -> Note where Note: NoteInterface<N> {\n        let options = NoteViewerOptions::new().set_limit(1);\n        view_notes(self.storage_slot, options)[0].unwrap()\n    }\n    // docs:end:view_note\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr"},"106":{"source":"use crate::context::{PrivateContext, PublicContext, Context};\nuse dep::std::option::Option;\nuse dep::protocol_types::{hash::pedersen_hash, traits::{ToField}};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\nstruct Map<K, V> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T> Storage<T> for Map<K, T> {}\n\nimpl<K, V> Map<K, V> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = pedersen_hash([self.storage_slot, key.to_field()], 0);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"113":{"source":"use dep::protocol_types::{hash::hash_args, traits::Hash};\n\nstruct Hasher {\n    fields: [Field],\n}\n\nimpl Hash for Hasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl Hasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/aztec/src/hasher.nr"},"188":{"source":"use dep::std::cmp::Eq;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic \n// if a value can actually be zero. In a future refactor, we can \n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\ntrait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field { fn empty() -> Self {0} }\n\nimpl Empty for u1 { fn empty() -> Self {0} }\nimpl Empty for u8 { fn empty() -> Self {0} }\nimpl Empty for u32 { fn empty() -> Self {0} }\nimpl Empty for u64 { fn empty() -> Self {0} }\nimpl Empty for U128 { fn empty() -> Self {U128::from_integer(0)} }\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, N>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\ntrait Hash {\n    fn hash(self) -> Field;\n}\n\ntrait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\n\n// docs:start:serialize\ntrait Serialize<N> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\n// docs:start:deserialize\ntrait Deserialize<N> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/traits.nr"},"193":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u64) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/utils.nr"},"194":{"source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS},\n    contract_class_id::ContractClassId, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        AztecAddress::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute_from_public_key(\n        pub_key: GrumpkinPoint,\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        portal_contract_address: EthAddress\n    ) -> AztecAddress {\n        AztecAddress::compute(\n            PublicKeysHash::compute(pub_key),\n            PartialAddress::compute(\n                contract_class_id,\n                salt,\n                initialization_hash,\n                portal_contract_address\n            )\n        )\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            pedersen_hash(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let contract_address_salt = 3;\n    let contract_class_id = ContractClassId::from_field(4);\n    let initialization_hash = 5;\n    let portal_contract_address = EthAddress::from_field(6);\n\n    let address = AztecAddress::compute_from_public_key(\n        point,\n        contract_class_id,\n        contract_address_salt,\n        initialization_hash,\n        portal_contract_address\n    );\n\n    assert(address.to_field() == 0x2fd71a4f0742364f194dd16d0ae32d2f47845ddc7f5d328f37d4148b565c4123);\n}\n\n#[test]\nfn compute_address_from_partial_and_pubkey() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let partial_address = PartialAddress::from_field(3);\n\n    let address = AztecAddress::compute(PublicKeysHash::compute(point), partial_address);\n    assert(address.to_field() == 0x0447f893197175723deb223696e2e96dbba1e707ee8507766373558877e74197);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/address/aztec_address.nr"},"195":{"source":"use crate::{\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, hash::pedersen_hash, grumpkin_point::GrumpkinPoint,\n    traits::{ToField, Serialize, Deserialize}\n};\n\n// Public keys hash. Used in the computation of an address.\nstruct PublicKeysHash {\n    inner: Field\n}\n\nimpl ToField for PublicKeysHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<1> for PublicKeysHash {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<1> for PublicKeysHash {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        PublicKeysHash::from_field(fields[0])\n    }\n}\n\nimpl Eq for PublicKeysHash {\n    fn eq(self, other: Self) -> bool {\n        self.inner == other.inner\n    }\n}\n\nimpl PublicKeysHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(public_key: GrumpkinPoint) -> Self {\n        PublicKeysHash::from_field(\n            pedersen_hash(\n                [\n            public_key.x,\n            public_key.y\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_public_keys_hash() {\n    let point = GrumpkinPoint { x: 1, y: 2 };\n    let actual = PublicKeysHash::compute(point);\n    assert(actual.to_field() == 0x1923a6246e305720b6aaf751fde0342613e93c82e455c3831e28375c16dd40d8);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/address/public_keys_hash.nr"},"199":{"source":"use crate::address::{AztecAddress, EthAddress};\nuse crate::mocked::VerificationKey;\nuse crate::abis::function_selector::FunctionSelector;\nuse crate::abis::function_leaf_preimage::FunctionLeafPreimage;\nuse crate::abis::contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage;\nuse crate::contract_class_id::ContractClassId;\nuse crate::abis::new_contract_data::NewContractData as ContractLeafPreimage;\nuse crate::abis::function_data::FunctionData;\nuse crate::abis::side_effect::{SideEffect};\nuse crate::utils::uint256::U256;\nuse crate::constants::{\n    ARGS_HASH_CHUNK_COUNT, ARGS_HASH_CHUNK_LENGTH, CONTRACT_TREE_HEIGHT, FUNCTION_TREE_HEIGHT,\n    NOTE_HASH_TREE_HEIGHT, NUM_FIELDS_PER_SHA256, GENERATOR_INDEX__SILOED_NOTE_HASH,\n    GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__VK, GENERATOR_INDEX__CONSTRUCTOR,\n    GENERATOR_INDEX__PARTIAL_ADDRESS, GENERATOR_INDEX__CONTRACT_ADDRESS,\n    GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__FUNCTION_ARGS\n};\nuse crate::messaging::l2_to_l1_message::L2ToL1Message;\n\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (sha256_hashed[15 - i] as Field) * v;\n        low = low + (sha256_hashed[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    let hash_in_a_field = low + high * v;\n\n    hash_in_a_field\n}\n\npub fn hash_args<N>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        for i in 0..ARGS_HASH_CHUNK_COUNT {\n            let mut chunk_hash = 0;\n            let start_chunk_index = i * ARGS_HASH_CHUNK_LENGTH;\n            if start_chunk_index < args.len() {\n                let mut chunk_args = [0; ARGS_HASH_CHUNK_LENGTH];\n                for j in 0..ARGS_HASH_CHUNK_LENGTH {\n                    let item_index = i * ARGS_HASH_CHUNK_LENGTH + j;\n                    if item_index < args.len() {\n                        chunk_args[j] = args[item_index];\n                    }\n                }\n                chunk_hash = pedersen_hash(chunk_args, GENERATOR_INDEX__FUNCTION_ARGS);\n            }\n            chunks_hashes[i] = chunk_hash;\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Checks that `value` is a member of a merkle tree with root `root` at position `index`\n// The witness being the `sibling_path`\npub fn assert_check_membership<N>(value: Field, index: Field, sibling_path: [Field; N], root: Field) {\n    let calculated_root = root_from_sibling_path(value, index, sibling_path);\n    assert(calculated_root == root, \"membership check failed\");\n}\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like \n// this because it means we never even need to consider cases where \n// the index is greater than p.\npub fn root_from_sibling_path<N>(leaf: Field, leaf_index: Field, sibling_path: [Field; N]) -> Field {\n    let mut node = leaf;\n    let indices = leaf_index.to_le_bits(N);\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\n// Calculate the function tree root from the sibling path and leaf preimage.\n//\n// TODO: The cpp code passes in components of the FunctionLeafPreimage and then \n// builds it up. We should build it up and then pass the leaf preimage as a parameter.\n// We can then choose to have a general method that takes in anything hashable\n// and deduplicate the logic in `contract_tree_root_from_siblings`\npub fn function_tree_root_from_siblings(\n    selector: FunctionSelector,\n    is_internal: bool,\n    is_private: bool,\n    vk_hash: Field,\n    acir_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = FunctionLeafPreimage { selector, is_internal, is_private, vk_hash, acir_hash };\n\n    let function_leaf = function_leaf_preimage.hash();\n\n    let function_tree_root = root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path);\n\n    function_tree_root\n}\n\n// Calculate the contract tree root from the sibling path and leaf preimage.\npub fn contract_tree_root_from_siblings(\n    contract_class_id: ContractClassId,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    contract_leaf_index: Field,\n    contract_leaf_sibling_path: [Field; CONTRACT_TREE_HEIGHT]\n) -> Field {\n    //TODO(Kev): if we use shorthand syntax here, we get an error as expected,\n    // since variable name is `storage_contract_address` but the span is incorrect.\n    let contract_leaf_preimage = ContractLeafPreimage { contract_address: storage_contract_address, portal_contract_address, contract_class_id };\n\n    let contract_leaf = contract_leaf_preimage.hash();\n\n    let computed_contract_tree_root = root_from_sibling_path(contract_leaf, contract_leaf_index, contract_leaf_sibling_path);\n\n    computed_contract_tree_root\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn read_request_root_from_siblings(\n    read_request: Field,\n    leaf_index: Field,\n    sibling_path: [Field; NOTE_HASH_TREE_HEIGHT]\n) -> Field {\n    root_from_sibling_path(read_request, leaf_index, sibling_path)\n}\n\npub fn silo_note_hash(address: AztecAddress, inner_commitment: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        inner_commitment\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\nfn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\n// TODO CPP uses blake2s for this\npub fn compute_new_contract_address_hash(new_contract_address: AztecAddress) -> Field {\n    dep::std::hash::pedersen_hash([new_contract_address.to_field()])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    rollup_version_id: Field,\n    chain_id: Field,\n    message: L2ToL1Message\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [\n        contract_address.to_field(), rollup_version_id, message.recipient.to_field(), chain_id, message.content\n    ];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn compute_constructor_hash(\n    function_data: FunctionData,\n    args_hash: Field,\n    constructor_vk_hash: Field\n) -> Field {\n    let function_data_hash = function_data.hash();\n\n    pedersen_hash(\n        [\n        function_data_hash,\n        args_hash,\n        constructor_vk_hash\n    ],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n\n// Computes sha256 hash of 2 input hashes stored in 4 fields.\n// \n// This method is bn254 specific. Two fields is needed in order to \n// encode the sha256 output. It can be abstracted away with any 4-2 hash function.\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\n// Returning a Field would be desirable because then this can be replaced with \n// poseidon without changing the rest of the code\n//\npub fn accumulate_sha256(input: [U128; 4]) -> [Field; NUM_FIELDS_PER_SHA256] {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    //\n    // Concatenate 4 u128 bit integers into a byte array.\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..4 {\n        let input_as_bytes = input[offset].to_be_bytes();\n        for byte_index in 0..16 {\n            hash_input_flattened[offset * 16 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    let sha_digest = dep::std::hash::sha256(hash_input_flattened);\n\n    U256::from_bytes32(sha_digest).to_u128_limbs()\n}\n\npub fn compute_logs_hash(\n    previous_log_hash: [Field; 2],\n    current_log_hash: [Field; 2]\n) -> [Field; NUM_FIELDS_PER_SHA256] {\n    accumulate_sha256(\n        [\n        U128::from_integer(previous_log_hash[0]),\n        U128::from_integer(previous_log_hash[1]),\n        U128::from_integer(current_log_hash[0]),\n        U128::from_integer(current_log_hash[1])\n    ]\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, commitment_index: u64) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        commitment_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_siloed_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        siloed_note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_unique_siloed_note_hashes<N>(\n    first_nullifier: Field,\n    siloed_note_hashes: [SideEffect; N]\n) -> [SideEffect; N] {\n    let mut unique_siloed_note_hashes = [SideEffect::empty(); N];\n    for i in 0..N {\n        let siloed_note_hash = siloed_note_hashes[i];\n        if siloed_note_hash.value != 0 {\n            let nonce = compute_note_hash_nonce(first_nullifier, i);\n            unique_siloed_note_hashes[i] = SideEffect {\n                value: compute_unique_siloed_note_hash(nonce, siloed_note_hash.value),\n                counter: siloed_note_hash.counter\n                };\n        }\n    }\n    unique_siloed_note_hashes\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n    assert(result == 0x142a6d57007171f6eaa33d55976d9dbe739c889c8e920f115f7808dea184c718);\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = [0; 800];\n    for i in 0..800 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    assert(hash == 0x371960dd84ed3445ab099ac4c1af5ba90e0c713b593e0ca52ee532087c7f097);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), 0, 0, L2ToL1Message::empty());\n    assert(hash_result == 0x2266ac2f9f0c19c015239ef5ea85862fc6fac00db73779b220a4d49c4856c2e1);\n\n    // Non-zero case\n    let message = L2ToL1Message { recipient: EthAddress::from_field(3), content: 5 };\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), 2, 4, message);\n    assert(hash_result == 0x0f24729168d4450a5681beafa5e3a899ac28bd17bf5a4877dab37bcd834e1634);\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/noir-protocol-circuits/src/crates/types/src/hash.nr"},"214":{"source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}},\n    note::{note_header::NoteHeader, note_interface::NoteInterface, utils::compute_note_hash_for_consumption},\n    oracle::{rand::rand, nullifier_key::get_nullifier_secret_key, get_public_key::get_public_key},\n    log::emit_encrypted_log, hash::pedersen_hash, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: Field = 3; // 3 plus a header.\n\n// docs:start:value-note-def\nstruct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n    header: NoteHeader,\n}\n// docs:end:value-note-def\n\nimpl NoteInterface<VALUE_NOTE_LEN> for ValueNote {\n    fn serialize_content(self) -> [Field; VALUE_NOTE_LEN] {\n        [self.value, self.owner.to_field(), self.randomness]\n    }\n\n    fn deserialize_content(serialized_note: [Field; VALUE_NOTE_LEN]) -> Self {\n        ValueNote {\n            value: serialized_note[0],\n            owner: AztecAddress::from_field(serialized_note[1]),\n            randomness: serialized_note[2],\n            header: NoteHeader::empty(),\n        }\n    }\n\n    fn compute_note_content_hash(self) -> Field {\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash(self.serialize_content(),0)\n    }\n\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = context.request_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    // docs:end:nullifier\n\n    fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_consumption(self);\n        let secret = get_nullifier_secret_key(self.owner);\n        // TODO(#1205) Should use a non-zero generator index.\n        pedersen_hash([\n            note_hash_for_nullify,\n            secret.low,\n            secret.high,\n        ],0)\n    }\n\n    fn set_header(&mut self, header: NoteHeader) {\n        self.header = header;\n    }\n\n    fn get_header(self) -> NoteHeader {\n        self.header\n    }\n\n    // Broadcasts the note as an encrypted log on L1.\n    fn broadcast(self, context: &mut PrivateContext, slot: Field) {\n        let encryption_pub_key = get_public_key(self.owner);\n        emit_encrypted_log(\n            context,\n            (*context).this_address(),\n            slot,\n            Self::get_note_type_id(),\n            encryption_pub_key,\n            self.serialize_content(),\n        );\n    }\n\n    fn get_note_type_id() -> Field {\n        // TODO(#4519): autogenerate\n        // python -c \"print(int(''.join(str(ord(c)) for c in 'ValueNote')))\"\n        869710811710178111116101\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        let randomness = rand();\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n","path":"/Users/zpedro/Documents/GitHub/aztec-packages/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}